using System.Text.Json;
using MockDynamoDB.Core.Expressions;
using MockDynamoDB.Core.Models;

namespace MockDynamoDB.Core.Operations;

/// <summary>
/// Parses the pre-expression DynamoDB request format.
///
/// Background: Before 2014, DynamoDB used structured comparison objects (attribute name →
/// { AttributeValueList, ComparisonOperator }) for conditions and updates. In 2014, AWS
/// introduced the expression language — KeyConditionExpression, FilterExpression,
/// UpdateExpression, ConditionExpression — which replaced these structured fields.
///
/// The pre-expression format remains part of the official DynamoDB wire protocol and is
/// still generated by:
///   - DynamoDBContext (high-level .NET SDK ORM): QueryAsync/ScanAsync use KeyConditions /
///     ScanFilter; SaveAsync uses AttributeUpdates; conditional writes use Expected.
///   - Older SDK versions, third-party tools, and hand-written requests targeting the
///     pre-expression API.
///
/// Pre-expression fields and their modern expression equivalents:
///   KeyConditions    → KeyConditionExpression  (Query)
///   QueryFilter      → FilterExpression        (Query)
///   ScanFilter       → FilterExpression        (Scan)
///   AttributeUpdates → UpdateExpression        (UpdateItem)
///   Expected         → ConditionExpression     (PutItem, UpdateItem, DeleteItem)
/// </summary>
internal static class PreExpressionRequestParser
{
    // -------------------------------------------------------------------------
    // KeyConditions (Query) — replaces KeyConditionExpression
    //
    // Wire format:
    //   "KeyConditions": {
    //     "<hashKey>": { "AttributeValueList": [<value>], "ComparisonOperator": "EQ" },
    //     "<rangeKey>": { "AttributeValueList": [<value>], "ComparisonOperator": "LE|LT|GE|GT|EQ|BEGINS_WITH|BETWEEN" }
    //   }
    // -------------------------------------------------------------------------
    internal static (AttributeValue pkValue, SortKeyCondition? skCondition) ParseKeyConditions(
        JsonElement keyConditions,
        string hashKeyName,
        string? rangeKeyName)
    {
        AttributeValue? pkValue = null;
        SortKeyCondition? skCondition = null;

        foreach (var prop in keyConditions.EnumerateObject())
        {
            var attrName = prop.Name;
            var op = prop.Value.GetProperty("ComparisonOperator").GetString()!;
            var valueList = prop.Value.GetProperty("AttributeValueList");
            var firstValue = ItemOperations.DeserializeAttributeValue(valueList[0]);

            if (attrName == hashKeyName)
            {
                if (op != "EQ")
                    throw new ValidationException("Query key condition not supported");
                pkValue = firstValue;
            }
            else if (attrName == rangeKeyName)
            {
                skCondition = op switch
                {
                    "EQ"          => new SortKeyCondition { Operator = "=",           Value = firstValue },
                    "LE"          => new SortKeyCondition { Operator = "<=",          Value = firstValue },
                    "LT"          => new SortKeyCondition { Operator = "<",           Value = firstValue },
                    "GE"          => new SortKeyCondition { Operator = ">=",          Value = firstValue },
                    "GT"          => new SortKeyCondition { Operator = ">",           Value = firstValue },
                    "BEGINS_WITH" => new SortKeyCondition { Operator = "begins_with", Value = firstValue },
                    "BETWEEN"     => new SortKeyCondition
                    {
                        Operator = "BETWEEN",
                        Value    = firstValue,
                        Value2   = ItemOperations.DeserializeAttributeValue(valueList[1])
                    },
                    _ => throw new ValidationException($"Unsupported ComparisonOperator: {op}")
                };
            }
        }

        if (pkValue == null)
            throw new ValidationException("Query condition missed key schema element: " + hashKeyName);

        return (pkValue, skCondition);
    }

    // -------------------------------------------------------------------------
    // ScanFilter / QueryFilter — replaces FilterExpression
    //
    // Wire format:
    //   "ScanFilter": {
    //     "<attr>": { "AttributeValueList": [...], "ComparisonOperator": "<op>" }
    //   },
    //   "ConditionalOperator": "AND" | "OR"   // default AND
    //
    // Supported operators: EQ, NE, LE, LT, GE, GT, NOT_NULL, NULL,
    //                      CONTAINS, NOT_CONTAINS, BEGINS_WITH, IN, BETWEEN
    // -------------------------------------------------------------------------
    internal static Func<Dictionary<string, AttributeValue>, bool> ParseFilterConditions(
        JsonElement filterElement,
        bool useOrOperator = false)
    {
        var conditions = new List<Func<Dictionary<string, AttributeValue>, bool>>();

        foreach (var prop in filterElement.EnumerateObject())
        {
            var attrName = prop.Name;
            var op = prop.Value.GetProperty("ComparisonOperator").GetString()!;

            List<AttributeValue> values = [];
            if (prop.Value.TryGetProperty("AttributeValueList", out var avl))
                values = avl.EnumerateArray().Select(ItemOperations.DeserializeAttributeValue).ToList();

            var attrNameCopy = attrName;
            var opCopy = op;
            var valuesCopy = values;

            conditions.Add(item =>
            {
                item.TryGetValue(attrNameCopy, out var val);
                return EvaluateComparisonOperator(val, opCopy, valuesCopy);
            });
        }

        return item => useOrOperator
            ? conditions.Any(c => c(item))
            : conditions.All(c => c(item));
    }

    // -------------------------------------------------------------------------
    // AttributeUpdates (UpdateItem) — replaces UpdateExpression
    //
    // Wire format:
    //   "AttributeUpdates": {
    //     "<attr>": { "Value": <AttributeValue>, "Action": "PUT" | "DELETE" | "ADD" }
    //   }
    //
    // Actions:
    //   PUT    — set the attribute to the given value
    //   DELETE — remove the attribute (no Value), or remove elements from a set (with Value)
    //   ADD    — add a number or union a set; creates the attribute if absent
    // -------------------------------------------------------------------------
    internal static void ApplyAttributeUpdates(
        JsonElement attributeUpdates,
        Dictionary<string, AttributeValue> item)
    {
        foreach (var prop in attributeUpdates.EnumerateObject())
        {
            var attrName = prop.Name;
            // Action defaults to PUT when omitted
            var action = prop.Value.TryGetProperty("Action", out var act) ? act.GetString()! : "PUT";

            switch (action)
            {
                case "PUT":
                    if (prop.Value.TryGetProperty("Value", out var putVal))
                        item[attrName] = ItemOperations.DeserializeAttributeValue(putVal);
                    break;

                case "DELETE":
                    if (prop.Value.TryGetProperty("Value", out var delVal))
                    {
                        // Remove specific elements from a set
                        var removeSet = ItemOperations.DeserializeAttributeValue(delVal);
                        if (item.TryGetValue(attrName, out var existing))
                        {
                            if (existing.SS != null && removeSet.SS != null)
                                existing.SS = existing.SS.Except(removeSet.SS).ToList();
                            else if (existing.NS != null && removeSet.NS != null)
                                existing.NS = existing.NS.Except(removeSet.NS).ToList();
                            else if (existing.BS != null && removeSet.BS != null)
                                existing.BS = existing.BS.Except(removeSet.BS).ToList();
                        }
                    }
                    else
                    {
                        item.Remove(attrName);
                    }
                    break;

                case "ADD":
                    if (prop.Value.TryGetProperty("Value", out var addVal))
                    {
                        var addValue = ItemOperations.DeserializeAttributeValue(addVal);
                        if (item.TryGetValue(attrName, out var existingVal))
                        {
                            // Add number or union set
                            if (existingVal.N != null && addValue.N != null)
                                existingVal.N = (decimal.Parse(existingVal.N) + decimal.Parse(addValue.N))
                                    .ToString(System.Globalization.CultureInfo.InvariantCulture);
                            else if (existingVal.SS != null && addValue.SS != null)
                                existingVal.SS = existingVal.SS.Union(addValue.SS).ToList();
                            else if (existingVal.NS != null && addValue.NS != null)
                                existingVal.NS = existingVal.NS.Union(addValue.NS).ToList();
                            else if (existingVal.BS != null && addValue.BS != null)
                                existingVal.BS = existingVal.BS.Union(addValue.BS).ToList();
                        }
                        else
                        {
                            item[attrName] = addValue;
                        }
                    }
                    break;
            }
        }
    }

    // -------------------------------------------------------------------------
    // Expected (PutItem, UpdateItem, DeleteItem) — replaces ConditionExpression
    //
    // Wire format:
    //   "Expected": {
    //     "<attr>": { "Value": <AttributeValue>, "Exists": true | false }
    //     -- OR --
    //     "<attr>": { "AttributeValueList": [...], "ComparisonOperator": "<op>" }
    //   },
    //   "ConditionalOperator": "AND" | "OR"   // default AND
    //
    // Exists: true  — attribute must exist (and equal Value if provided)
    // Exists: false — attribute must not exist
    // -------------------------------------------------------------------------
    internal static void EvaluateExpected(
        JsonElement expected,
        string? conditionalOperator,
        Dictionary<string, AttributeValue>? existingItem)
    {
        bool useOrOperator = conditionalOperator == "OR";

        var results = new List<bool>();

        foreach (var prop in expected.EnumerateObject())
        {
            var attrName = prop.Name;
            AttributeValue? resolvedVal = existingItem != null && existingItem.TryGetValue(attrName, out var av) ? av : null;

            bool result;

            if (prop.Value.TryGetProperty("Exists", out var exists))
            {
                var mustExist = exists.GetBoolean();
                var attrExists = existingItem != null && existingItem.ContainsKey(attrName);

                if (mustExist)
                {
                    if (!attrExists)
                    {
                        result = false;
                    }
                    else if (prop.Value.TryGetProperty("Value", out var expectedVal))
                    {
                        var expected2 = ItemOperations.DeserializeAttributeValue(expectedVal);
                        result = resolvedVal != null && ConditionEvaluator.CompareValues(resolvedVal, expected2) == 0;
                    }
                    else
                    {
                        result = true;
                    }
                }
                else
                {
                    result = !attrExists;
                }
            }
            else if (prop.Value.TryGetProperty("ComparisonOperator", out var compOp))
            {
                List<AttributeValue> values = [];
                if (prop.Value.TryGetProperty("AttributeValueList", out var avl))
                    values = avl.EnumerateArray().Select(ItemOperations.DeserializeAttributeValue).ToList();

                result = EvaluateComparisonOperator(resolvedVal, compOp.GetString()!, values);
            }
            else if (prop.Value.TryGetProperty("Value", out var directVal))
            {
                // Shorthand: attribute must equal value
                var expectedValue = ItemOperations.DeserializeAttributeValue(directVal);
                result = resolvedVal != null && ConditionEvaluator.CompareValues(resolvedVal, expectedValue) == 0;
            }
            else
            {
                result = true;
            }

            results.Add(result);
        }

        bool passed = useOrOperator ? results.Any(r => r) : results.All(r => r);
        if (!passed)
            throw new ConditionalCheckFailedException();
    }

    // -------------------------------------------------------------------------
    // Shared comparison operator evaluation
    // -------------------------------------------------------------------------
    private static bool EvaluateComparisonOperator(
        AttributeValue? val,
        string op,
        List<AttributeValue> values)
    {
        var first  = values.Count > 0 ? values[0] : null;
        var second = values.Count > 1 ? values[1] : null;

        return op switch
        {
            "NULL"         => val == null || val.NULL == true,
            "NOT_NULL"     => val != null && val.NULL != true,
            "EQ"           => val != null && first != null && ConditionEvaluator.CompareValues(val, first) == 0,
            "NE"           => val != null && first != null && ConditionEvaluator.CompareValues(val, first) != 0,
            "LE"           => val != null && first != null && ConditionEvaluator.CompareValues(val, first) <= 0,
            "LT"           => val != null && first != null && ConditionEvaluator.CompareValues(val, first) < 0,
            "GE"           => val != null && first != null && ConditionEvaluator.CompareValues(val, first) >= 0,
            "GT"           => val != null && first != null && ConditionEvaluator.CompareValues(val, first) > 0,
            "BEGINS_WITH"  => val?.S != null && first?.S != null && val.S.StartsWith(first.S, StringComparison.Ordinal),
            "BETWEEN"      => val != null && first != null && second != null
                              && ConditionEvaluator.CompareValues(val, first) >= 0
                              && ConditionEvaluator.CompareValues(val, second) <= 0,
            "CONTAINS"     => first != null && AttributeContains(val, first),
            "NOT_CONTAINS" => first != null && !AttributeContains(val, first),
            "IN"           => val != null && values.Any(v => ConditionEvaluator.CompareValues(val, v) == 0),
            _              => throw new ValidationException($"Unsupported ComparisonOperator: {op}")
        };
    }

    private static bool AttributeContains(AttributeValue? val, AttributeValue search)
    {
        if (val == null) return false;
        if (val.S  != null && search.S != null) return val.S.Contains(search.S, StringComparison.Ordinal);
        if (val.SS != null && search.S != null) return val.SS.Contains(search.S);
        if (val.NS != null && search.N != null) return val.NS.Contains(search.N);
        if (val.BS != null && search.B != null) return val.BS.Contains(search.B);
        if (val.L  != null) return val.L.Any(v => ConditionEvaluator.CompareValues(v, search) == 0);
        return false;
    }
}

/// <summary>
/// Represents a sort key condition extracted from either KeyConditionExpression or
/// the pre-expression KeyConditions format.
/// </summary>
internal sealed record SortKeyCondition
{
    public required string Operator { get; init; }
    public AttributeValue? Value  { get; init; }
    public AttributeValue? Value2 { get; init; } // BETWEEN only
}
